"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateQueryFiles = void 0;
const edgedb_1 = require("edgedb");
const ifaces_1 = require("edgedb/dist/ifaces");
const commandutil_1 = require("./commandutil");
async function generateQueryFiles(params) {
    var _a;
    if (params.options.file && params.options.watch) {
        throw new Error(`Using --watch and --file mode simultaneously is not
currently supported.`);
    }
    const noRoot = !params.root;
    const root = (_a = params.root) !== null && _a !== void 0 ? _a : edgedb_1.adapter.process.cwd();
    if (noRoot) {
        console.warn(`No \`edgedb.toml\` found, using process.cwd() as root directory:
   ${params.root}
`);
    }
    else {
        console.log(`Detected project root via edgedb.toml:`);
        console.log("   " + params.root);
    }
    const client = (0, edgedb_1.createClient)({
        ...params.connectionConfig,
        concurrency: 5
    });
    const matches = await getMatches(root);
    if (matches.length === 0) {
        console.log(`No .edgeql files found in project`);
        edgedb_1.adapter.exit();
        return;
    }
    console.log(`Connecting to database...`);
    await client.ensureConnected();
    console.log(`Analyzing .edgeql files...`);
    if (params.options.file) {
        const filesByExtension = {};
        let wasError = false;
        await Promise.all(matches.map(async (path) => {
            const prettyPath = "./" + edgedb_1.adapter.path.posix.relative(root, path);
            try {
                const query = await edgedb_1.adapter.readFileUtf8(path);
                const types = await edgedb_1.$.analyzeQuery(client, query);
                console.log(`   ${prettyPath}`);
                const files = generateFiles({
                    target: params.options.target,
                    path,
                    types
                });
                for (const f of files) {
                    if (!filesByExtension[f.extension]) {
                        filesByExtension[f.extension] = f;
                    }
                    else {
                        filesByExtension[f.extension].contents += `\n\n` + f.contents;
                        filesByExtension[f.extension].imports = {
                            ...filesByExtension[f.extension].imports,
                            ...f.imports
                        };
                    }
                }
            }
            catch (err) {
                wasError = true;
                console.log(`Error in file '${prettyPath}': ${err.toString()}`);
            }
        }));
        if (!wasError) {
            console.log(`Generating query file${Object.keys(filesByExtension).length > 1 ? "s" : ""}...`);
            for (const [extension, file] of Object.entries(filesByExtension)) {
                const filePath = (edgedb_1.adapter.path.isAbsolute(params.options.file)
                    ? params.options.file
                    : edgedb_1.adapter.path.join(edgedb_1.adapter.process.cwd(), params.options.file)) + extension;
                const prettyPath = edgedb_1.adapter.path.isAbsolute(params.options.file)
                    ? params.options.file + extension
                    : "./" + edgedb_1.adapter.path.posix.relative(root, filePath);
                console.log(`   ${prettyPath}`);
                await edgedb_1.adapter.fs.writeFile(filePath, `// GENERATED by @edgedb/generate v${(0, commandutil_1.getPackageVersion)()}\n` +
                    `// Run 'npx @edgedb/generate queries --file' to re-generate\n\n` +
                    `${stringifyImports(file.imports)}\n\n${file.contents}`);
            }
        }
        edgedb_1.adapter.exit();
        return;
    }
    async function generateFilesForQuery(path) {
        try {
            const query = await edgedb_1.adapter.readFileUtf8(path);
            if (!query)
                return;
            const types = await edgedb_1.$.analyzeQuery(client, query);
            const files = generateFiles({
                target: params.options.target,
                path,
                types
            });
            for (const f of files) {
                const prettyPath = "./" + edgedb_1.adapter.path.posix.relative(root, f.path);
                console.log(`   ${prettyPath}`);
                await edgedb_1.adapter.fs.writeFile(f.path, `// GENERATED by @edgedb/generate v${(0, commandutil_1.getPackageVersion)()}\n` +
                    `// Run 'npx @edgedb/generate queries' to re-generate\n\n` +
                    `${stringifyImports(f.imports)}\n\n${f.contents}`);
            }
        }
        catch (err) {
            console.log(`Error in file './${edgedb_1.adapter.path.posix.relative(root, path)}': ${err.toString()}`);
        }
    }
    console.log(`Generating files for following queries:`);
    await Promise.all(matches.map(generateFilesForQuery));
    if (!params.options.watch) {
        edgedb_1.adapter.exit();
        return;
    }
}
exports.generateQueryFiles = generateQueryFiles;
function stringifyImports(imports) {
    if (Object.keys(imports).length === 0)
        return "";
    return `import type {${Object.keys(imports).join(", ")}} from "edgedb";`;
}
async function getMatches(root) {
    return edgedb_1.adapter.walk(root, {
        match: [/[^\/]\.edgeql$/],
        skip: [/node_modules/, RegExp(`dbschema\\${edgedb_1.adapter.path.sep}migrations`)]
    });
}
function generateFiles(params) {
    const queryFileName = edgedb_1.adapter.path.basename(params.path);
    const method = params.types.cardinality === ifaces_1.Cardinality.ONE
        ? "queryRequiredSingle"
        : params.types.cardinality === ifaces_1.Cardinality.AT_MOST_ONE
            ? "querySingle"
            : "query";
    const functionName = queryFileName
        .replace(/\.edgeql$/, "")
        .replace(/-[A-Za-z]/g, m => m[1].toUpperCase())
        .replace(/^[^A-Za-z_]|\W/g, "_");
    const imports = {};
    for (const i of params.types.imports) {
        imports[i] = true;
    }
    const tsImports = { Executor: true, ...imports };
    const hasArgs = params.types.args && params.types.args !== "null";
    const tsImpl = `async function ${functionName}(client: Executor${hasArgs ? `, args: ${params.types.args}` : ""}): Promise<${params.types.result}> {
  return client.${method}(\`${params.types.query
        .trim()
        .replace(/`/g, "\\`")}\`${hasArgs ? `, args` : ""});
}`;
    const jsImpl = `async function ${functionName}(client${hasArgs ? `, args` : ""}) {
  return client.${method}(\`${params.types.query.replace(/`/g, "\\`")}\`${hasArgs ? `, args` : ""});
}`;
    const dtsImpl = `function ${functionName}(client: Executor${hasArgs ? `, args: ${params.types.args}` : ""}): Promise<${params.types.result}>;`;
    switch (params.target) {
        case "cjs":
            return [
                {
                    path: `${params.path}.js`,
                    contents: `${jsImpl}\n\nmodule.exports.${functionName} = ${functionName};`,
                    imports: {},
                    extension: ".js"
                },
                {
                    path: `${params.path}.d.ts`,
                    contents: `export ${dtsImpl}`,
                    imports: tsImports,
                    extension: ".d.ts"
                }
            ];
        case "deno":
            return [
                {
                    path: `${params.path}.ts`,
                    contents: `export ${tsImpl}`,
                    imports: tsImports,
                    extension: ".ts"
                }
            ];
        case "esm":
            return [
                {
                    path: `${params.path}.mjs`,
                    contents: `export ${jsImpl}`,
                    imports: {},
                    extension: ".mjs"
                },
                {
                    path: `${params.path}.d.ts`,
                    contents: `export ${dtsImpl}`,
                    imports: tsImports,
                    extension: ".d.ts"
                }
            ];
        case "mts":
            return [
                {
                    path: `${params.path}.mts`,
                    contents: `export ${tsImpl}`,
                    imports: tsImports,
                    extension: ".mts"
                }
            ];
        case "ts":
            return [
                {
                    path: `${params.path}.ts`,
                    contents: `export ${tsImpl}`,
                    imports: tsImports,
                    extension: ".ts"
                }
            ];
    }
}
