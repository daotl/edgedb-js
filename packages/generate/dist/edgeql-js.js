"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateQueryBuilder = exports.exitWithError = exports.configFileHeader = void 0;
const edgedb_1 = require("edgedb");
const commandutil_1 = require("./commandutil");
const edgedb_2 = require("edgedb");
const builders_1 = require("./builders");
const FILES_1 = require("./FILES");
const generateCastMaps_1 = require("./edgeql-js/generateCastMaps");
const generateFunctionTypes_1 = require("./edgeql-js/generateFunctionTypes");
const generateGlobals_1 = require("./edgeql-js/generateGlobals");
const generateIndex_1 = require("./edgeql-js/generateIndex");
const generateObjectTypes_1 = require("./edgeql-js/generateObjectTypes");
const generateOperatorTypes_1 = require("./edgeql-js/generateOperatorTypes");
const generateRuntimeSpec_1 = require("./edgeql-js/generateRuntimeSpec");
const generateScalars_1 = require("./edgeql-js/generateScalars");
const generateSetImpl_1 = require("./edgeql-js/generateSetImpl");
const { path, fs, readFileUtf8, exists, exit, walk } = edgedb_1.adapter;
const headerComment = `// GENERATED by @edgedb/generate v${(0, commandutil_1.getPackageVersion)()}\n` +
    `// Run 'npx @edgedb/generate edgeql-js' to re-generate\n\n`;
exports.configFileHeader = `// EdgeDB query builder. To update, run \`npx @edgedb/generate edgeql-js\``;
function exitWithError(message) {
    console.error(message);
    exit(1);
    throw new Error();
}
exports.exitWithError = exitWithError;
async function generateQueryBuilder(params) {
    const { root, options, connectionConfig } = params;
    let outputDir;
    if (options.out) {
        outputDir = path.isAbsolute(options.out)
            ? options.out
            : path.join(edgedb_1.adapter.process.cwd(), options.out);
    }
    else if (root) {
        outputDir = path.join(root, "dbschema", "edgeql-js");
    }
    else {
        throw new Error(`No edgedb.toml found. Initialize an EdgeDB project with\n\`edgedb project init\` or specify an output directory with \`--output-dir\``);
    }
    let outputDirIsInProject = false;
    let prettyOutputDir;
    if (root) {
        const relativeOutputDir = path.posix.relative(root, outputDir);
        outputDirIsInProject =
            !relativeOutputDir.startsWith("..");
        prettyOutputDir = outputDirIsInProject
            ? `./${relativeOutputDir}`
            : outputDir;
    }
    else {
        prettyOutputDir = outputDir;
    }
    if (await exists(outputDir)) {
        if (await canOverwrite(outputDir, options)) {
        }
    }
    else {
        options.updateIgnoreFile = true;
    }
    const target = options.target;
    let cxn;
    try {
        cxn = (0, edgedb_2.createClient)({
            ...connectionConfig,
            concurrency: 5
        });
    }
    catch (e) {
        exitWithError(`Failed to connect: ${e.message}`);
    }
    const dir = new builders_1.DirBuilder();
    try {
        console.log(`Introspecting database schema...`);
        const [types, scalars, casts, functions, operators, globals] = await Promise.all([
            edgedb_2.$.introspect.types(cxn),
            edgedb_2.$.introspect.scalars(cxn),
            edgedb_2.$.introspect.casts(cxn),
            edgedb_2.$.introspect.functions(cxn),
            edgedb_2.$.introspect.operators(cxn),
            edgedb_2.$.introspect.globals(cxn)
        ]);
        const typesByName = {};
        for (const type of types.values()) {
            typesByName[type.name] = type;
            if (!type.name.includes("::"))
                continue;
        }
        const generatorParams = {
            dir,
            types,
            typesByName,
            casts,
            scalars,
            functions,
            globals,
            operators
        };
        (0, generateRuntimeSpec_1.generateRuntimeSpec)(generatorParams);
        (0, generateCastMaps_1.generateCastMaps)(generatorParams);
        (0, generateScalars_1.generateScalars)(generatorParams);
        (0, generateObjectTypes_1.generateObjectTypes)(generatorParams);
        (0, generateFunctionTypes_1.generateFunctionTypes)(generatorParams);
        (0, generateOperatorTypes_1.generateOperators)(generatorParams);
        (0, generateSetImpl_1.generateSetImpl)(generatorParams);
        (0, generateGlobals_1.generateGlobals)(generatorParams);
        (0, generateIndex_1.generateIndex)(generatorParams);
        const importsFile = dir.getPath("imports");
        importsFile.addExportStar("edgedb", { as: "edgedb" });
        importsFile.addExportFrom({ spec: true }, "./__spec__", {
            allowFileExt: true
        });
        importsFile.addExportStar("./syntax", {
            allowFileExt: true,
            as: "syntax"
        });
        importsFile.addExportStar("./castMaps", {
            allowFileExt: true,
            as: "castMaps"
        });
    }
    finally {
        await cxn.close();
    }
    const initialFiles = new Set(await walk(outputDir));
    const written = new Set();
    const syntaxOutDir = path.join(outputDir);
    if (!(await exists(syntaxOutDir))) {
        await fs.mkdir(syntaxOutDir);
    }
    const syntaxFiles = FILES_1.syntax[target];
    if (!syntaxFiles) {
        throw new Error(`Error: no syntax files found for target "${target}"`);
    }
    for (const f of syntaxFiles) {
        const outputPath = path.join(syntaxOutDir, f.path);
        written.add(outputPath);
        let oldContents = "";
        try {
            oldContents = await readFileUtf8(outputPath);
        }
        catch { }
        const newContents = headerComment + f.content;
        if (oldContents !== newContents) {
            await fs.writeFile(outputPath, newContents);
        }
    }
    if (target === "ts") {
        await dir.write(outputDir, {
            mode: "ts",
            moduleKind: "esm",
            fileExtension: ".ts",
            moduleExtension: "",
            written
        }, headerComment);
    }
    else if (target === "mts") {
        await dir.write(outputDir, {
            mode: "ts",
            moduleKind: "esm",
            fileExtension: ".mts",
            moduleExtension: ".mjs",
            written
        }, headerComment);
    }
    else if (target === "cjs") {
        await dir.write(outputDir, {
            mode: "js",
            moduleKind: "cjs",
            fileExtension: ".js",
            moduleExtension: "",
            written
        }, headerComment);
        await dir.write(outputDir, {
            mode: "dts",
            moduleKind: "esm",
            fileExtension: ".d.ts",
            moduleExtension: "",
            written
        }, headerComment);
    }
    else if (target === "esm") {
        await dir.write(outputDir, {
            mode: "js",
            moduleKind: "esm",
            fileExtension: ".mjs",
            moduleExtension: ".mjs",
            written
        }, headerComment);
        await dir.write(outputDir, {
            mode: "dts",
            moduleKind: "esm",
            fileExtension: ".d.ts",
            moduleExtension: "",
            written
        }, headerComment);
    }
    else if (target === "deno") {
        await dir.write(outputDir, {
            mode: "ts",
            moduleKind: "esm",
            fileExtension: ".ts",
            moduleExtension: ".ts",
            written
        }, headerComment);
    }
    const configPath = path.join(outputDir, "config.json");
    await fs.writeFile(configPath, `${exports.configFileHeader}\n${JSON.stringify({ target })}\n`);
    written.add(configPath);
    for (const file of initialFiles) {
        if (written.has(file)) {
            continue;
        }
        await fs.rm(file);
    }
    console.log(`Writing files to ${prettyOutputDir}`);
    console.log(`Generation complete! ðŸ¤˜`);
    if (!outputDirIsInProject || !root) {
        console.log(`\nChecking the generated files into version control is
not recommended. Consider updating the .gitignore of your
project to exclude these files.`);
    }
    else if (options.updateIgnoreFile) {
        const gitIgnorePath = path.join(root, ".gitignore");
        let gitIgnoreFile = null;
        try {
            gitIgnoreFile = await readFileUtf8(gitIgnorePath);
        }
        catch { }
        const vcsLine = path.posix.relative(root, outputDir);
        if (gitIgnoreFile === null ||
            !RegExp(`^${vcsLine}$`, "m").test(gitIgnoreFile)) {
            if (await (0, commandutil_1.promptBoolean)(gitIgnoreFile === null
                ? `Checking the generated query builder into version control
is not recommended. Would you like to create a .gitignore file to ignore
the query builder directory? `
                : `Checking the generated query builder into version control
is not recommended. Would you like to update .gitignore to ignore
the query builder directory? The following line will be added:

   ${vcsLine}\n\n`, true)) {
                await fs.appendFile(gitIgnorePath, `${gitIgnoreFile === null ? "" : "\n"}${vcsLine}\n`);
            }
        }
    }
}
exports.generateQueryBuilder = generateQueryBuilder;
async function canOverwrite(outputDir, options) {
    if (options.forceOverwrite) {
        return true;
    }
    let config = null;
    try {
        const configFile = await readFileUtf8(path.join(outputDir, "config.json"));
        if (configFile.startsWith(exports.configFileHeader)) {
            config = JSON.parse(configFile.slice(exports.configFileHeader.length));
            if (config.target === options.target) {
                return true;
            }
        }
    }
    catch { }
    const error = config
        ? `A query builder with a different config already exists in that location.`
        : `Output directory '${outputDir}' already exists.`;
    if ((0, commandutil_1.isTTY)() &&
        (await (0, commandutil_1.promptBoolean)(`${error}\nDo you want to overwrite? `, true))) {
        return true;
    }
    return exitWithError(`Error: ${error}`);
}
